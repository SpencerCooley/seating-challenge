<template>
  <q-page class="page-wrapper">
    <q-btn size="lg" v-if="!guests.length" @click="seatAllGuests"
      >Seat Guests</q-btn
    >
    <q-btn size="lg" v-if="guests.length" @click="clearPreviousGuestMap"
      >Clear</q-btn
    >
    <div class="grid-wrap">
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.a"
        v-bind:key="guest"
        >{{ guest }}</a
      >
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.b"
        v-bind:key="guest"
        >{{ guest }}</a
      >
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.c"
        v-bind:key="guest"
        >{{ guest }}</a
      >
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.d"
        v-bind:key="guest"
        >{{ guest }}</a
      >
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.e"
        v-bind:key="guest"
        >{{ guest }}</a
      >
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.f"
        v-bind:key="guest"
        >{{ guest }}</a
      >
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.g"
        v-bind:key="guest"
        >{{ guest }}</a
      >
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.h"
        v-bind:key="guest"
        >{{ guest }}</a
      >
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.i"
        v-bind:key="guest"
        >{{ guest }}</a
      >
      <a
        :href="`#/itinerary/${guest}`"
        class="seat"
        v-for="guest in seating.j"
        v-bind:key="guest"
        >{{ guest }}</a
      >
    </div>
  </q-page>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { Guest } from '../components/models';
import { useGuestStore } from '../stores/guest';

const store = useGuestStore();

const randomIntFromInterval = (min: number, max: number) => {
  // min and max included
  return Math.floor(Math.random() * (max - min + 1) + min);
};

const seating = ref({
  a: [],
  b: [],
  c: [],
  d: [],
  e: [],
  f: [],
  g: [],
  h: [],
  i: [],
  j: [],
});

// an array that holds the guest list generated by generateGuestList();
const guests = ref<Guest[]>([]);
// a value mostly for debugging purposes to see how many were generated by generateGuestList();
const peopleCount = ref(0);

const clearPreviousGuestMap = () => {
  // clear the previous generated list.
  guests.value = [];
  peopleCount.value = 0;
  seating.value = {
    a: [],
    b: [],
    c: [],
    d: [],
    e: [],
    f: [],
    g: [],
    h: [],
    i: [],
    j: [],
  };
  // clear the pinia store
  store.setSeating(seating.value);
  store.setSeating(guests.value);
};

// a reference object for seeing seat availability by row.
const seatsAvailable = computed(() => {
  let availability = {};
  // this tells us how many seats are available in each row.
  for (let row in seating.value) {
    availability[row] = 10 - seating.value[row].length;
  }
  return availability;
});

// a reference value to check what row we are currently in the process of filling.
const currentRow = computed(() => {
  for (let row in seatsAvailable.value) {
    if (
      seatsAvailable.value.hasOwnProperty(row) &&
      seatsAvailable.value[row] !== 0
    ) {
      return row;
    }
  }
  return null;
});

//function for generating the guest list.
const generateGuests = () => {
  //ensures we start with new data every time the function is run.
  clearPreviousGuestMap();

  // as long as the people count is less than a hundred we will keep generating new guests.
  for (let i = 0; peopleCount.value < 100; i++) {
    //write the typescript model.
    let companionCount = randomIntFromInterval(0, 5);
    let packageID = randomIntFromInterval(1, 5);

    let newGuest = <Guest>{
      id: i,
      companions: companionCount,
      name: `guest_${i}`,
      packageID: packageID,
    };

    // accounts for the original guest + their invited companions.
    peopleCount.value += companionCount + 1;

    // add to list.
    guests.value.push(newGuest);
  }
};

// function for seating guests
const sortAndSeatGuests = () => {
  // a reference object to grab guest groups by number of seats.
  let sorter = {
    1: [],
    2: [],
    3: [],
    4: [],
    5: [],
    6: [],
  };

  // sort all the groups by group size
  for (let group of guests.value) {
    let groupSize = group.companions + 1;
    // sort the generated list by group size.
    sorter[groupSize].push(group.id);
  }

  let seatGroup = (size, row, shift) => {
    if (sorter[size].length) {
      for (let i = 0; i < size; i++) {
        seating.value[row].push(sorter[size][0]);
      }
      if (shift) {
        sorter[size].shift();
      }
    }
  };

  let edgeCaseWrapCounter = 0;
  let targetGroup;

  const seatWithPerfectFit = (possibleGroupSizes, seatsLeftInRow, shift) => {
    // use mod to find the largest group number that will fit in the rows perfectly.
    let modsToZero = possibleGroupSizes.filter(
      (item) => seatsLeftInRow % item === 0
    );
    if (modsToZero.length) {
      // use the larger number
      seatGroup(Math.max(...modsToZero), currentRow.value, shift);
    } else {
      // this means there are no perfectly divisible number to fill the row.
      // just use whatever is left in the possible arrangments.
      seatGroup(Math.max(possibleGroupSizes[0]), currentRow.value, shift);
    }
  };

  const wrapGroupToNextRow = (leftOverGuests) => {
    // if this is being run it means we are wrapping a group around to the next row
    // leftOverGuests is the number of guests left that need to be sat in the next row
    for (let i = 0; i < leftOverGuests; i++) {
      seating.value[currentRow.value].push(sorter[targetGroup][0]);
    }
    //reset these variables so that the algorithm continues to seat as normal.
    edgeCaseWrapCounter = 0;
    sorter[targetGroup].shift();
    targetGroup = null;
  };

  const fillRemainingSeatsInRow = (seatsLeftInRow) => {
    // if his happens there are still some groups left, they just don't fit in the current row.
    // we need to fill the current row and resume fill seats on the next row in next iteration.
    // doesn't matter what we grab. anything in there is going to be bigger than the row and will wrap.
    for (let item in Object.values(sorter)) {
      if (Object.values(sorter)[item].length) {
        targetGroup = Object.keys(sorter)[item];
      }
    }

    // fill remaining seats in current row.
    for (let i = 0; i < seatsLeftInRow; i++) {
      seating.value[currentRow.value].push(sorter[targetGroup][0]);
    }
    // this will be how many time you add the target group to the next row.
    edgeCaseWrapCounter = parseInt(targetGroup) - seatsLeftInRow;
    // now on the next iteration add the rest of this to the next row
    // use the edgeCaseWrapCounter to subtract from the amount of iterations needed.
  };

  const calculatePossibleGroupSizes = (seatsLeftInRow) => {
    // choose the largest number between 1 and 6 that is also less than or equal to seatsLeftInRow
    let possibleGroupSizes = [];

    for (const groupSize in sorter) {
      if (sorter[groupSize].length && groupSize <= seatsLeftInRow) {
        // list of still available group sizes to use to fill row
        possibleGroupSizes.push(groupSize);
      }
    }
    return possibleGroupSizes;
  };

  // while loop will keep adding guests until there are no more seats left.
  // see the computed property currentRow
  while (currentRow.value !== null) {
    //shift is being used as a marker to determine what seating function we should use.
    let shift = edgeCaseWrapCounter === 0;
    let seatsLeftInRow = seatsAvailable.value[currentRow.value];

    // returns an array of possible group sizes that can fit in the current row.
    const possibleGroupSizes = calculatePossibleGroupSizes(seatsLeftInRow);

    // this chunk does all the seating.
    if (possibleGroupSizes.length) {
      if (edgeCaseWrapCounter === 0) {
        //always attempt to get a perfect fit.
        // if not possible then this function will change the value of edgeCaseWrapCounter
        // so we can wrap a group in the next couple iterations.
        seatWithPerfectFit(possibleGroupSizes, seatsLeftInRow, shift);
      } else {
        // previous row was filled
        // now need to seat the remaining member of the group on the next row.
        wrapGroupToNextRow(edgeCaseWrapCounter);
      }
    } else {
      // no possible leftover group sizes will perfectly fit in the current row
      // so we fill the current row with a group that will need to wrap to next row
      fillRemainingSeatsInRow(seatsLeftInRow);
    }
  }
  //reverse every other row
  //so that wrapped groups will at least share some columns.
  seating.value.b.reverse();
  seating.value.d.reverse();
  seating.value.f.reverse();
  seating.value.h.reverse();
  seating.value.j.reverse();
};

const seatAllGuests = ref(() => {
  // function to generate all the guests
  generateGuests();
  // function to sort and seat and the guests.
  sortAndSeatGuests();

  // save relevant to the store so we can use this data on the itinerary page.
  store.setSeating(seating.value);
  store.setGuestList(guests.value);
});

onMounted(async () => {
  guests.value = store.guestList;
  seating.value = store.seatingChart;

  // get the packages from redis cache and save to the pinia store for later use.
  fetch('https://redis-endpoint-kk7djpeknq-uc.a.run.app/')
    .then((response) => response.json())
    .then((data) => store.setPackagesList(data));
});
</script>
<style lang="scss">
.grid-wrap {
  padding-top: 20px;
  width: 90%;

  display: grid;
  grid-template-columns: 8% 8% 8% 8% 8% 8% 8% 8% 8% 8%;
  grid-gap: 2%;
  .seat {
    color: #fff;
    text-decoration: none;
    &:hover {
      opacity: 0.8;
      cursor: pointer;
    }
    border-radius: 80px;
    text-align: center;
    padding: 5px;
    background-color: #1976d2;
  }
}
</style>
